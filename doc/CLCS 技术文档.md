# CLCS 技术文档

## 服务端和客户端的职责

### 服务端

* 维护，管理当前在线的用户
* 维护用户的公匙
* 转发客户端之间的通信

### 客户端

* 加密/解密聊天信息
* 维护与自己有关的用户
* 维护与服务器的连接

---

## 文件夹结构

**文件工作结构**

```
CLCS程序目录结构
   ├── 运行程序
   ├── history
   │   ├── user1
   │   └── user2
   ├── keys
   ├── log
   └── option
       ├── language
       │   ├── standard.txt
       │   └── zh_CN.txt
       └── options.txt

```

```
history： 存放聊天的内容
option：	 存放程序的一系列设置
log:	  存放日志
keys:     存放用户的公钥信息
```

**项目文件夹**

```
.
├── CLCS-client
│   ├── CMakeLists.txt
│   ├── include
│   └── resource
├── CLCS-server
│   ├── CMakeLists.txt
│   ├── include
│   └── resource
├── CMakeLists.txt
├── doc
├── LICENSE
├── public
│   ├── CMakeLists.txt
│   ├── include
│   └── resource
└── README.md

```

```
doc： 			存放参考文档
CLCS-client	     存放客户端的相关的文件
CLCS-server		 存放服务端的相关的文件
public		     存放公共部分的代码

    include： 		存放头文件
    resources： 		存放.cc文件
```

---

## 文档格式

### 变量命名规范：

1. 清楚明了的知道这个词在程序中的作用
2. 简洁，但不会让人误解



### 语言模块，设置模块文件格式：

```
"字符串1"："字符串2"
```

```
字符串1：程序中原字符串
字符串2：显示的字符串
```

### 命令行指令格式

```
[动作名字] [参数]
```

示例：

```
发出回调消息 "hello world"
recall "hello world"

添加uuid为 51c44468-329e-4df6-8771-5d6350842ec5 的用户
add 51c44468-329e-4df6-8771-5d6350842ec5
```

#### 命令行指令详解

**此信息可在程序中输入`help`显示**

```
help
        输出此条信息

reset_target
        重新设置目标服务器的ip和地址

re_connect
        重新连接目标服务器

cat
        查看信息
        cat [参数]
                time 当前系统的时间
                uuid 自己的uuid
                user 当前已经保存的用户
                connect 与服务器的连接状态
                latency 与服务器的延迟

recall
        向服务器发送回调消息
        recall [消息]

add
        添加用户信息
        add [uuid]

rename
        更改用户的昵称
        rename [uuid/旧昵称] [新昵称]

send
        向用户发送消息
        send [uuid/昵称] [消息]

save
        保存设置

quit
        退出程序
```

示例:

##### 客户端

1. 显示help信息

```
help
```

2. 重设目标服务器的`ip`和`端口`

```
reconnect

recnnect [目标ip] [目标端口]
```

3. 重新连接服务器

```
re_connect
```

4. `cat`命令

```
查看自己的uuid
cat uuid

查看当前系统的时间
cat time

查看当前已保存的用户
cat user

查看与服务端的连接状态
cat connect

查看与服务器的延迟
cat latency

===注：参数可以连用===

查看自己的uuid和系统的时间
cat uuid time
```

5. 添加用户

```
add [目标uuid]
```

6. 向服务器发送`recall`信息

```
recall [消息的内容]

示例：发送recall消息 hello world
recall "hello world"
```

7. 为指定用户起名称

```
rename [目标用户的uuid/目标用户的昵称] [新的昵称]
```

8. 向指定用户发送消息

```
send [目标用户的uuid/昵称] [消息的内容]

示例：向uuid为51c44468-329e-4df6-8771-5d6350842ec5， 昵称为user1的用户发送 hello
send 51c44468-329e-4df6-8771-5d6350842ec5 "hello"
send user1 "hello"
```

9. 保存当前的设置信息和用户信息

```
save
```

10. 保存并退出程序

```
quit
```

##### 服务端

1. 保存并退出程序

```
quit
```

### 信息流格式

```
[消息类型] [额外参数]
[目标uuid] [自己的uuid]
[消息长度]\n
[消息主体]
```

信息流由**头标记 + 消息内容构成**

头标记包含了**当前信息的类型**，**额外参数1**， **额外参数2**, **目标uuid**，**自己的uuid**， **消息的长度**， **消息的主体**构成

* `NOMEAN`：表示无意义， 用于填充字符
* 当前仅`TEXT_CHAT`类型的信息流需要使用公钥加密， 其他类型的信息流的信息内容不加密

#### 信息流详解

* RECALL： 回调指令


```
RECALL NOMEAN NOMEAN
[目标uuid] [自己的uuid]
[消息长度]\n
[消息]
```

* TEXT_CHAT：聊天

```
TEXT_CHAT NOMEAN NOMEAN
[目标UUID] [自己的UUID]
[消息长度]\n
[消息](使用目标的公钥加密)
```

* TEXT_SYS：向服务器做请求
  * INIT_SYS    初始化系统、客户端 
  * TIME    测试当前的延迟
  * ADD_USER 添加用户
    * REQUEST 发送请求(未完成)
    * ACCESS    同意(未完成)
    * REJECT     拒绝(未完成)

```
客户端发出
TEXT_SYS INIT_SYS NOMEAN
[空uuid] [自己的uuid]
[公钥的长度]\n
[公钥]

服务端发出
TEXT_SYS INIT_SYS NOMEAN
[客户端uuid] [服务器自己的uuid]
[消息的长度]\n
[消息](无作用， 所以设置内容为 ok )
```

```
TEXT_SYS TIME NOMEAN
[服务器uuid] [自己的uuid]
[消息长度]\n
[当前的时间]
```

```
客户端发出
TEXT_SYS ADD_USER NOMEAN
[服务器uuid] [客户端uuid]
[消息长度]\n
[想添加的uuid]

服务端发出
TEXT_SYS ADD_USER NOMEAN
[客户端uuid] [服务器uuid]
[消息长度]\n
[请求用户的公钥]
```

---

## 程序运行大致过程

### 服务端

1. 初始化各大模块
2. 开辟一个线程来运行`epoll`反应堆
   1. 监听是否有连接
   2. 若有连接则将其与客户端进行连接
   3. 监听该客户端发来的消息， 通过判断客户端发来的**头标记**来执行相应的函数
3. 监听用户输入， 若输入为`quit`则退出程序

### 客户端

1. 初始化各大模块
2. 开辟一个线程来监听从服务端发来的消息
   1. 若收到消息， 则根据头标记来执行相应的函数来处理
3. 主线程监听用户的输入
   1. 若接受到了输入
   2. 根据输入的消息执行相应的函数

---

## 客户端与服务端的交互

### 交互的基础

采用**特定结构的信息流**来实现当前的客户端与目标服务器的交互

信息流的结构如下：

```
信息流 = 头标记 + 信息内容

头标记 = 信息流类型 + 信息流属性1 + 信息流属性2 + 目标uuid + 自己的uuid + 发送消息的长度 + \n
```

### 客户端与服务端的连接

1. 客户端与服务端使用`socket`连接以后， 客户端向服务端自动发送`TEXT_SYS INIT_SYS NOMEAN`信息流， 向服务端说明`自己的uuid`和`自己的公钥`。

2. 服务端接收到信息以后会检查该用户的`uuid`是否有记录， 若有记录， 则不保存公钥，若无记录， 则保存公钥。 
3. 服务端将用户信息添加到在线人员名单中，并向客户端发送`TEXT_SYS INIT_SYS NOMEAN`信息流， 向客户端说明自己的`uuid`
4. 客户端接受到该消息以后会初始化当前服务端的`uuid`

自此，客户端与服务端连接完成

### 客户端向服务端发送RECALL信息

1. 设置信息流的格式， 读取要发送的信息
1. 消息生成器生成对应的消息流
1. 向服务器发送`RECALL NOMEAN NOMEAN` 信息流
1. 服务器接受到了以后将消息流原封不动的返回给客户端
1. 客户端接受到该消息流以后调用相应的函数将消息显示出来

### 客户端向客户端发送消息

1. 发送方设置信息流格式， 目标用户的`uuid`和要发送的内容
2. 消息生成器生成对应的消息流
3. 发送方向服务端发送`TEXT_CHAT NOMEAN NOMEAN`信息流
4. 服务器接受到信息流以后读取接收方的`uuid`
5. 检查该`uuid`是否在`在线用户列表`中，若存在， 则将消息转发给接收方，若不存在，则忽略该信息流
6. 接收方接受到该信息流以后将消息内容解密， 然后调取相应的函数将消息显示出来

### 客户端添加用户

1. 客户端设置信息流，想添加的用户的`uuid`
2. 向服务端发送`TEXT_SYS ADD_USER NOMEAN`消息流
3. 服务端接受消息
4. 检查该请求的uuid是否存在， 若存在，则设置相应的消息流， 发送该用户的公钥， 若不存在，发送null
5. 服务端发送消息流
6. 客户端读取消息流以后执行相应的函数来添加用户

### 客户端测试与服务端的延迟

1. 客户端设置消息流， 设置内容为当前系统的时间
2. 向服务端发送`TEXT_SYS TIME NOMEAN`消息流
3. 服务端接收到该消息以后将消息原封不动的传给客户端，处理方式与`recall`消息一致
4. 客户端接受到该消息以后读取内容， 并读取当前的系统的时间
5. 计算两个时间的差值
6. 显示该差值

---

## 类的说明

### `startInit`类

作用：初始化整个模块， 承担了 **初始化各大模块** 和 **初始化工作文件夹** 的职责

设计模式： 单例设计模式

* 初始化程序

### `Log`类

作用：程序的日志模块， 负责向一个**指定的位置**输出经过**格式化的数据**

设计模式： 单例模式

信息格式

```
%t：当前线程的id
%p：当前进程的id
%c：当前系统的时间
%m：程序运行的时间
%e：当前程序errno的值
```

默认是在`log`文件夹下创建一个当前时间的日志文件

* 设置日志输出的地方（暂时不能手动设置）
* 输出日志
* 强行退出程序，并输出日志



* 设置目标文件路径
* 获取目标文件路径
* 判断当前的输出对象是否是控制台
* 退出程序，并记录日志

### `FileManager`类

作用：程序的路径管理模块

设计模式：单例模式

* 获取指定的目录路径

### `Default`类

作用：

1. 为其他的类创建文件时提供一个初始化模板
2. 用于校验读到的数据是否存在丢失



### `Language`类

（半成品，需要改进）

作用：程序的语言管理模块

通过获取当前语言，然后去指定的文件读取相应的语言

* 若不存在该语言， 则根据`Default`类，创建一个以该语言命令的文件，作为该语言的文件
* 若存在该语言，但是文件中的记录与`Default`类中的记录不匹配， 则日志系统将其记录下来，然后结束程序

* 设置当前程序的语言（半成品）

### `Setting`类

作用：为其他的模块提供参数的**初始化的值**， 同时也会保存设置的值，在程序下一次运行的时候依然会保持不变

若程序是第一次运行，则会要求用户进行设置

* 初始化程序
* 获取指定的设置内容
* 保存当前的设置内容

### `User_Manager`类

用于管理用户的模块，承担一系列用户相关的功能

设计模式：单例模式

* 获取自己的`uuid`
* 获取自己的公钥路径
* 获取自己的私钥路径
* 设置服务器的`uuid`
* 通过`uuid`来查找公钥路径
* 通过公钥路径来查找公钥的内容
* 获取指定的用户
* 添加用户
* 删除用户（未完善）
* 根据`uuid`或者昵称查找用户
* 重命名用户
* 获取用户数据库的信息
* 保存用户信息
* 检查一个字符串是否是`uuid`



### `Epoll_Reactor`类

作用： 在服务端上用来与客户端做连接。

可以不设置本地的`ip`和端口，若不设置本地的`ip`,则会自动选择可用的`ip`, 若不选择端口， 则会自动选择`6000`端口

设计模式：单例模式

使用`linux`的epoll函数为基础，封装出来的

* 添加，修改，删除监听任务
* 读取信息流
* 解析信息流
* 发送`recall`消息
* 发送`INIT_SYS`消息
* 返回用户公钥的消息

### `Server_Connector`类

作用：在客户端上，向指定的服务器做连接。

必须指定服务器的端口， 若`ip`或端口设置的不正确，则日志系统将输出错误报告， 程序退出



* 设置连接目标的`ip`和`端口`
* 开始连接
* 关闭连接
* 获取当前的文件描述符
* 获取当前的连接状态
* 阻塞连接（未完成）


### `ThreadPool`类

作用：程序的线程池， 会自动扩充线程和销毁线程。用于快速处理程序的数据。

通过向线程池插入一个一个的任务来完成对数据的处理

设计模式：单例模式

任务有**两个**模式

| 模式      | 效果                                   |
| --------- | -------------------------------------- |
| `DO_ONCE` | 函数执行完一次以后就销毁               |
| `DO_KEEP` | 为当前函数单独分配一个线程，不断的执行 |

封装`linux`的`pthread`库

* 启动线程池
* 添加任务
* 设置最大的线程数
* 设置最小的线程数
* 设置变化的线程数
* 设置自检的时间
* 获取当前最大的线程数
* 获取当前最小的线程数
* 获取当前变化的线程数
* 获取当前自检的时间
* 获取当前正在工作的线程的数量


### `Command_Analysis`类

作用：解析用户的命令，并执行相应的函数

* 检查用户的命令



### `Command_Service`类

作用：用于给`Command_Analysis`类设置规范（明确什么命令是有效的，这个命令的作用是什么， 执行什么函数）

* 显示帮助页面
* 分析当前的参数
* 添加命令
* 获取命令
* 设置命令是否是一个命令组（如`cat`， 可以实现`cat user uuid time` ）

### `Business`类

作用：**客户端**的业务逻辑

里面所有的函数均为**静态函数**， 变量均为**静态变量**

* 重设`ip`和`端口`
* 重新连接目标服务器
* 查看当前连接状态
* 测试与服务器的延迟
* 监听服务器的信息流
* 保存当前的设置和用户信息
* 查看并显示`uuid`，系统时间， 保存的用户信息
* 执行`RECALL`消息的发送
* 执行`TEXT_CHAT`消息的发送
* 重命名用户
* 添加用户
* 自动初始化服务器
* 显示接收到的`recall`消息
* 显示接收到的用户消息
* 自动添加用户
* 显示延迟

---

### `ReadFile`类

作用：读文件的父类， 当前是`ReadWithLine`, `ReadUser`的父类

* 设置文件路径
* 获取文件路径
* 查看是否存在错误

### `WriteFile` 类

作用：写文件的父类，当前是`WriteWithLine`， `WriteUser`的父类

* 设置文件路径
* 获取当前文件路径
* 查看是否存在错误

---

### `ReadWithLine ` 类

作用：从某一个给定的文件中以一个`特定的格式`一行一行地读取文件，然后存放到哈希表中

与`WriteWithLine`相对应

* 读取消息， 并存放到相应的数据结构中

### `WriteWithLine` 类

作用：向某一个给定的文件一行一行地写入**特定格式**的数据

与`ReadWithLine`相对应

* 读取指定的内容
* 写入文件

### `ReadUser`类

读取一个字符串， 并解析， 获取返回用户信息

* 读取用户信息
* 设置文件路径



### `WriteUser`类

将用户输入写入到指定的文件中

* 写入文件
* 设置文件路径



### `MessageGenerator`类

通过设置的信息流格式， 目标用户， 发送的消息来生成对应的信息流

只需要设置目标的`uuid`即可， 会自动添加自己的`uuid`， 要先设置目标`uuid`再设置内容， 否则当涉及到加密内容时会加密失败



* 设置信息流的格式和参数
* 设置目标用户
* 设置消息内容
* 获取信息流的头格式
* 获取信息
* 获取信息的长度
* 设置消息的长度



### `MessageAnalysis`类

解析读到的信息流，将信息流分解为各个部分， 同时判断头标记的正确性

头标记的判断：查看信息流的属性和信息流的参数是否匹配， 目前未判断信息流的头标记是否齐全



* 从一个指定的`MessageReceiver`读取一个完整的信息流， 并将其解析
* 获取流类型
* 获取参数1
* 获取参数2
* 获取目标`uuid`
* 获取源`uuid`
* 获取消息的原始数据
* 获取解密过后的数据
* 获取原始消息的长度

* 检查头标记的正确性



### `MessageSender`类

将指定的消息发送到指定的地方



* 设置连接器（低阶）
* 发送特定的消息（低阶）



### `Message_Process`类


用于处理客户端和服务器之间的通讯的过程，用于处理生成信息， 处理信息，然后发送信息

封装了`MessageGenerator`, `MessageSender`,` Server_connector`三个系统， 将原来`MessageSender`这个类进行了拆分

* 发送测试延迟信息的信息流（高阶）
* 发送`RECALL`消息流（高阶）
* 向指定用户发送指定消息流（高阶）
* 发送初始化服务器消息流（高阶）
* 发送添加用户消息流（高阶）



### `MessageReceiver`类

读取来自服务器的消息

* 读取头标记
* 获取头标记
* 读取消息内容
* 获取消息内容
* 设置消息的长度
* 设置服务器的文件描述符
* 获取当前服务器的文件描述符
* 设置连接器

### `RSA_controller`类

生成`rsa`密钥

* 设置私钥路径
* 设置公钥路径
* 生成密钥

### `RSA_encrypt`类

加密信息

* 读取公钥
* 设置公钥路径
* 设置并读取公钥路径
* 转换信息
* 设置加密的内容
* 获取加密后的消息的长度
* 获取加密后的消息的内容



### `RSA_decrypt`类

解密信息

* 读取私钥
* 设置私钥路径
* 设置并读取私钥路径
* 转换信息
* 设置解密的内容及其长度
* 获取解密后的消息的内容



---

### `User`类

描述一个用户的类

```
char _uuid[37];		// 当前用户的uuid
char _name[33];	    // 当前用户的昵称
int fd;             // 当前的文件描述符（未使用，待删除）
std::string _pub_path // 当前用户的公钥路径
std::String _pri_path // 当前用户的私钥路径（未使用，待删除）
```



### `Event`类

描述epoll反应堆的一个事务

```
std::list<Event>::iterator _index;          // 当前的点在维护数组中的位置
int _socket_fd = 0;       	// 当前的操作符
int _events = 0;         	// 当前事件的状态
std::function<void()> _func;// 回调函数
time_t _last_active = 0;    // 上一次运行的事件（暂未使用）

char header[BUFSIZ];			// 存放头标记
int header_len = 0;				// 头标记的长度

// 解析头标记以后的内容
char level;
char option1;
char option2;
std::string source_uuid;
std::string target_uuid;
int content_len = 0;            // 缓冲区的大小

bool is_content = false;			 // 是否该读取内容了
std::shared_ptr<unsigned char> _buf; // 消息内容缓冲区
```



### `MessageHeader`类

描述信息的属性

```
typedef char Level;
static const char RECALL = 1;		// 回环属性
static const char TEXT_CHAT = 2;	// 聊天信息
static const char TEXT_SYS = 3;		// 系统信息
static const char KEY_TEST = 4;		// 密钥信息

typedef char Option;
static const char NOMEAN = 0;		// 无意义
static const char SEND = 1;			// 当前信息是由发送端发送的
static const char RECV = 2;			// 当前信息是用来回应发送端的
static const char USER_LIST = 3;	// 数据的内容为当前的在线用户
```

### `Service`类

提供命令的信息和执行的函数入口

```
std::map<std::string, Service> _store; 	// 保存他的子类， 从而实现命令的嵌套
std::string description; 				// 当前命令的描述
std::string name;						// 当前命令的名字
std::string format;						// 当前命令的格式
```

## 后期优化

1. 使用`move`， `forword`等函数优化拷贝复制操作符
2. 添加系统请求限制， 防止请求过高导致服务器卡顿
2. 完善日志系统的输出功能
2. 完善所有函数的错误处理
